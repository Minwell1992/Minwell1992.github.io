<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Java多线程编程(一) | Minwell</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&amp;gt;《java并发编程实践》（理论掌握）-&amp;gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。下面就记录一下我的一些心得体会~本文介绍了多线程的基础，比如创建线程，以及synchronized和volatile关键字等。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程编程(一)">
<meta property="og:url" content="http://Minwell1992.github.io/Java多线程编程-一.html">
<meta property="og:site_name" content="Minwell">
<meta property="og:description" content="最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&amp;gt;《java并发编程实践》（理论掌握）-&amp;gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。下面就记录一下我的一些心得体会~本文介绍了多线程的基础，比如创建线程，以及synchronized和volatile关键字等。">
<meta property="og:updated_time" content="2016-07-05T11:49:47.603Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程编程(一)">
<meta name="twitter:description" content="最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&amp;gt;《java并发编程实践》（理论掌握）-&amp;gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。下面就记录一下我的一些心得体会~本文介绍了多线程的基础，比如创建线程，以及synchronized和volatile关键字等。">
  
    <link rel="alternative" href="/atom.xml" title="Minwell" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars3.githubusercontent.com/u/12514772?v=3&amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Minwell</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">文章目录</a></li>
				        
							<li><a href="/about/index.html">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Minwell1992" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/wangxc666" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="/mooner1992@126.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Java并发编程/" style="font-size: 20px;">Java并发编程</a> <a href="/tags/个人项目/" style="font-size: 10px;">个人项目</a> <a href="/tags/串口通信/" style="font-size: 10px;">串口通信</a> <a href="/tags/容器/" style="font-size: 20px;">容器</a> <a href="/tags/杂谈/" style="font-size: 13.33px;">杂谈</a> <a href="/tags/设计模式/" style="font-size: 16.67px;">设计模式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Minwell</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars3.githubusercontent.com/u/12514772?v=3&amp;s=460" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Minwell</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">文章目录</a></li>
		        
					<li><a href="/about/index.html">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Minwell1992" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/wangxc666" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="/mooner1992@126.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Java多线程编程-一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/Java多线程编程-一.html" class="article-date">
  	<time datetime="2016-06-13T12:12:46.000Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java多线程编程(一)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java并发编程/">Java并发编程</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&gt;《java并发编程实践》（理论掌握）-&gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。<br>下面就记录一下我的一些心得体会~<br>本文介绍了多线程的基础，比如创建线程，以及synchronized和volatile关键字等。<br><a id="more"></a></p>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>这个是基础中的基础啦，两种方式，最好选择实现接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_1CreateNewThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">super</span>.run();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">					System.out.println(<span class="string">"MyThread1"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">					System.out.println(<span class="string">"MyThread2"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程启动顺序与调用start()方法顺序无关。</span><br></pre></td></tr></table></figure></p>
<h2 id="一个典型线程不安全例子"><a href="#一个典型线程不安全例子" class="headerlink" title="一个典型线程不安全例子"></a>一个典型线程不安全例子</h2><p>这个例子中，对变量a设置了延迟，导致必然出现线程不安全。加锁就可以恢复正常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3ThreadSafe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ALogin a = <span class="keyword">new</span> ALogin();</span><br><span class="line">		BLogin b = <span class="keyword">new</span> BLogin();</span><br><span class="line">		a.start(); b.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> String userNameRef;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> String passWordRef;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPost</span> <span class="params">(String userName, String passWord)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				userNameRef = userName;</span><br><span class="line">				<span class="keyword">if</span> (userName.equals(<span class="string">"a"</span>))</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				passWordRef = passWord;</span><br><span class="line">				System.out.println(<span class="string">"username="</span> + userNameRef + </span><br><span class="line">						<span class="string">" password="</span> + passWordRef);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ALogin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			LoginServlet.doPost(<span class="string">"a"</span>, <span class="string">"aa"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BLogin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			LoginServlet.doPost(<span class="string">"b"</span>, <span class="string">"bb"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，在main方法中，只能实现静态内部类或者非静态成员内部类。而静态类也有很多的坑，比如私有构造方法无效，可以new，等等。</p>
<h2 id="syso与i–"><a href="#syso与i–" class="headerlink" title="syso与i–"></a>syso与i–</h2><p>syso方法是线程安全的，源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    print(x);</span><br><span class="line">	    newLine();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，要小心其中的i–：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_4SumNum</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread run = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t4 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t5 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">		t5.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.currentThread().getName() + <span class="string">" i="</span> + i--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，可以发现有一定的概率会出现线程安全问题。这是因为println()方法内在同步，但是i–的操作是进入方法前完成的，所以有几率发生问题。</p>
<h2 id="几个常用方法"><a href="#几个常用方法" class="headerlink" title="几个常用方法"></a>几个常用方法</h2><h3 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h3><p>currentThread()方法返回代码段正在被哪个线程调用的信息，API的原文是</p>
<pre><code>Returns a reference to the currently executing thread object.
</code></pre><p>若不重写Thread方法，此时this.currentThread()跟Thread.currentThread()无任何区别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_5CurrentThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> CountOperate();</span><br><span class="line">		t1.setName(<span class="string">"ThreadA"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountOperate</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">CountOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"CountOperate--begin"</span>);</span><br><span class="line">			System.out.println(<span class="string">"current thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"this.getName():"</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">			System.out.println(<span class="string">"CountOperate--end"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"run--begin"</span>);</span><br><span class="line">			System.out.println(<span class="string">"current thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"this.getName():"</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">			System.out.println(<span class="string">"run--end"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>CountOperate--begin
current thread:main
this.getName():Thread-0
CountOperate--end
run--begin
current thread:ThreadA
this.getName():ThreadA
run--end
</code></pre><p>可以看到，Thread.currentThread()是main线程，this是当前线程。</p>
<h3 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h3><p>isAlive()方法表示当前线程是否为活动状态，即线程已启动，且未终止的状态。API中的原文是：</p>
<pre><code>Tests if this thread is alive. A thread is alive if it has been started and has not yet died.
</code></pre><h3 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h3><p>表示当前线程睡眠n个ms。需要检查异常InterrupttedException。<br>有一个很重要的知识点，同样是等待，sleep()和wait()的区别是什么呢？sleep()睡眠，但是并不释放锁。而wait()将锁释放，表示当前线程正在等待，只有notify()方法被调用后才会醒来。<br>此外，最好使用TimeUnit.··.sleep()方法来替代sleep()方法。因为sleep()只能表示ms，而TimeUnit类可以直观的表示睡眠了多少m，s，ms，ns，等，可读性很强。</p>
<h3 id="getId-方法"><a href="#getId-方法" class="headerlink" title="getId()方法"></a>getId()方法</h3><p>获取线程唯一标识。并不可以通过setId()来设置其id。观察其源码，发现id是内部生成的，作为其标识。</p>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>需要有技巧的安全的停止线程。主要有3个方法，后文将详细介绍。</p>
<ol>
<li>使用退出标志，正常退出，即run方法完成后线程终止；</li>
<li>stop()方法强制退出(这种方式已废弃)；</li>
<li>interrupt()方法中断线程。并不会强制终止，而是传入中断信号，还需要线程配合判断才能真正的终止。</li>
</ol>
<h3 id="interrupted-和isInterrupted"><a href="#interrupted-和isInterrupted" class="headerlink" title="interrupted()和isInterrupted()"></a>interrupted()和isInterrupted()</h3><p>两个方法的源码声明如下，可以发现非常的相像：</p>
<pre><code>public boolean isInterrupted() {}
public static boolean interrupted() {}
</code></pre><p>两者的区别：</p>
<ul>
<li>this.interrupted():测试当前是否中断，执行后将标志重置为false；</li>
<li>this.isInterrupted():测试线程Thread对象是否是中断状态，不清除标志位。</li>
</ul>
<p>利用中断可以灵活的终止线程,if (this.interrupted())来检测</p>
<ul>
<li>仅仅跳出循环，可以检测时break；</li>
<li>若需要退出线程，抛出InterrupttedException异常，并检测即可；</li>
<li>也可以使用return来退出，但不如异常方式，因为可以一层一层向上抛出。</li>
</ul>
<p>若处于睡眠，进行中断则会进入InterrupttedException异常中。需要注意的是，无论睡眠与否，若中断打开，那么都会抛出异常。</p>
<h3 id="暂停线程suspend和resume方法"><a href="#暂停线程suspend和resume方法" class="headerlink" title="暂停线程suspend和resume方法"></a>暂停线程suspend和resume方法</h3><p>与stop一样都是被废除的方法。使用不当极易造成公共对象独占，导致死锁。而且还有不同步等缺点。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>作用是放弃当前cpu资源，让给逼得资源。但放弃的时间不确定，有可能刚刚放弃，马上又获得了时间片。<br>在测试yield的方法时，发现电脑循环500w后用时2ms？然后循环5000w后还是2ms？实验室的电脑性能只能说一般，一定是哪里有问题。这个问题先搁置，以后有空解决下。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>不能依赖java中的优先级。优先级还是取决于系统，有些系统根本就不认可java的优先级。设置方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(n)</span><br></pre></td></tr></table></figure></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>java中有两种线程，一种是用户线程，一种是守护线程。<br>守护线程是一种特殊的线程，我理解为“保姆”线程。典型的守护线程就是垃圾回收线程。当进程中没有非守护线程，那么垃圾回收线程也就没有必要了，自动销毁。守护线程的存在意义就是被守护线程。<br>设置方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="关键字synchronized-和-volatile"><a href="#关键字synchronized-和-volatile" class="headerlink" title="关键字synchronized 和 volatile"></a>关键字synchronized 和 volatile</h1><p>java中与同步相关的主要就是这两个关键字，下面来研究研究。</p>
<h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><p>syncronized意思是同步，相对应异步是asyncronized。syncronized为重量级锁，安全但是比较笨重。</p>
<h3 id="私有变量线程安全"><a href="#私有变量线程安全" class="headerlink" title="私有变量线程安全"></a>私有变量线程安全</h3><p>私有变量作用域仅在方法内部，因此不存在线程安全问题。而成员变量在方法外部，会产生竞争使用的问题，有可能线程不安全。</p>
<h3 id="对象与锁"><a href="#对象与锁" class="headerlink" title="对象与锁"></a>对象与锁</h3><p>synchronized是对象锁，锁住的是对象，而不是代码。因此，对于不同的对象，每个对象有自己的锁。只有共享的资源才需要同步，若不是共享资源，那么根本没有同步的必要。<br>此外，在对象内部，若A先持有对象的锁，那么B可以异步调用对象的非synchronized方法；而B调用synchronized方法时则需要等待A释放锁。代码运行结果清晰地表示出来这个特性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_2LockObject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyObject o = <span class="keyword">new</span> MyObject();</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA(o);</span><br><span class="line">		a.setName(<span class="string">"A"</span>);</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThreadB(o);</span><br><span class="line">		b.setName(<span class="string">"B"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"Begin method is "</span> + Thread.currentThread().getName());</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(<span class="string">"End time "</span> + System.currentTimeMillis());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//add lock</span></span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"Begin method is "</span> + Thread.currentThread().getName()</span><br><span class="line">						+ <span class="string">" Begin time is "</span> + System.currentTimeMillis());</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(<span class="string">"End"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> MyObject object; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(MyObject object)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.object = object;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			object.methodA();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> MyObject object; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadB</span><span class="params">(MyObject object)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.object = object;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			object.methodB();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="脏读-dirty-read"><a href="#脏读-dirty-read" class="headerlink" title="脏读(dirty read)"></a>脏读(dirty read)</h3><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还未同步，这时，另外一个事务也访问这个数据，然后使用了这个数据。下面这个例子中，getValue()先于setValue()执行完毕，此时setValue()执行了一半，数据未完全同步，因此会调用出错，出现脏读。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3DirtyRead</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		PublicVar p = <span class="keyword">new</span> PublicVar();</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA(p);</span><br><span class="line">		a.start();</span><br><span class="line">		Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		p.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PublicVar</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> String username = <span class="string">"A"</span>;</span><br><span class="line">		<span class="keyword">public</span> String password = <span class="string">"AA"</span>;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.username = username;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="keyword">this</span>.password = password;</span><br><span class="line">				System.out.println(<span class="string">"setValue thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">				System.out.println(<span class="string">"username:"</span> + username + <span class="string">" password:"</span> + password);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		dirty read</span></span><br><span class="line"><span class="comment">//		synchronized</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"getValue thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"username:"</span> + username + <span class="string">" password:"</span> + password);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> PublicVar publicVar; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(PublicVar publicVar)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.publicVar = publicVar;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			publicVar.setValue(<span class="string">"B"</span>, <span class="string">"BB"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h3><p>锁重入指的是持有锁的线程试图获得锁时，请求会成功。换种说法，就是再一个synchronized方法内部调用本类其他synchronized方法时，永远会拿到锁。更为规范的<a href="http://ifeve.com/java_lock_see4/" target="_blank" rel="external">说法</a>是这样的：</p>
<blockquote>
<p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。</p>
</blockquote>
<p>举个栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_4LockIn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"service1"</span>);</span><br><span class="line">			service2();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"service2"</span>);</span><br><span class="line">			service3();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"service3"</span>);</span><br><span class="line"><span class="comment">//			service1();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			Service service = <span class="keyword">new</span> Service();</span><br><span class="line">			service.service1();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，service1()调用锁上的service2()，又调用service3()。印证了可以递归调用这一说法。<br>可重入锁最大的作用是避免死锁。以自旋锁作为例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, current))&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于自旋锁来说，</p>
<ol>
<li>若有同一线程两调用lock() ，会导致第二次调用lock位置进行自旋，产生了死锁。说明这个锁并不是可重入的。（在lock函数内，应验证线程是否为已经获得锁的线程）</li>
<li>若1问题已经解决，当unlock（）第一次调用时，就已经将锁释放了。实际上不应释放锁。（采用计数次进行统计）</li>
</ol>
<p>设置标志位count，重入时+1，释放时-1。修改之后，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span>(current==owner.get()) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, current))&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span>(current==owner.get())&#123;</span><br><span class="line">			<span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">				count--;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该自旋锁即为可重入锁。<br>此外，可重入锁也支持父子类继承的环境中，子类可以通过可重入锁来调用父类的同步方法。</p>
<h3 id="锁与异常"><a href="#锁与异常" class="headerlink" title="锁与异常"></a>锁与异常</h3><p>当一个线程代码出现异常时，锁会自动释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_5LockAndExeption</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Service s = <span class="keyword">new</span> Service();</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA(s);</span><br><span class="line">		a.setName(<span class="string">"a"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThreadB(s);</span><br><span class="line">		b.setName(<span class="string">"b"</span>);</span><br><span class="line">		b.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Thread name is "</span>+ Thread.currentThread().getName()</span><br><span class="line">						+ <span class="string">". run beginTime is "</span> + System.currentTimeMillis());</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((<span class="string">""</span> + Math.random()).substring(<span class="number">0</span>, <span class="number">8</span>).equals(<span class="string">"0.123456"</span>)) &#123;</span><br><span class="line">						System.out.println(<span class="string">"ThreadName is "</span> + Thread.currentThread().getName()</span><br><span class="line">								+ <span class="string">". run exceptionTime is "</span> + System.currentTimeMillis());</span><br><span class="line">						Integer.parseInt(<span class="string">"a"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> </span><br><span class="line">				System.out.println(<span class="string">"Thread B runTime is"</span> + System.currentTimeMillis());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Service service;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.service = service;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			service.testMethod();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Service service;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadB</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.service = service;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			service.testMethod();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="同步不能继承"><a href="#同步不能继承" class="headerlink" title="同步不能继承"></a>同步不能继承</h3><p>当子类重写父类方法的时候，如果不加入同步标志，一样不具备同步性。</p>
<h2 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h2><p>synchronized代码块更加灵活，只将需要同步的对象同步，而别的部分是异步执行。可以既保持同步又提高性能。<br>当一个线程访问synchronized(this)代码块，其他线程对同一个对象中其他synchronized(this)代码块访问将被阻塞。<br>推广来说，synchronized(x)中x可以为任意对象，有以下几个性质：</p>
<ol>
<li>多个线程同时执行synchronized(x){}同步代码块时同步；</li>
<li>其他线程执行x对象内的synchronized同步方法同步；</li>
<li>其他线程执行x对象synchronized(this)代码块同步。</li>
</ol>
<h3 id="String的一些问题"><a href="#String的一些问题" class="headerlink" title="String的一些问题"></a>String的一些问题</h3><p>String对象处于常量池中，同内容对象在内存中只有一份。如果持有String对象的锁，那么很容易造成不同对象持有相同的锁，造成线程同步问题。因此大多数情况下，同步synchronized代码块都不使用String作为锁对象，而改用其他。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile主要有两个作用，分别是可见性与有序性。可见性指的是线程更新变量，所有线程都将更新这个变量。有序性指的是volatile变量代码段不使用重排序功能。<br>volatile实现可见性主要原理是这样的：每次读取该变量，强制从公共内存中读取，更改变量后，又写入公共内存中。但其最大的缺点就是不支持原子性。<br>volatile和synchronized都是同步关键字，有什么不同呢？主要是以下几点：</p>
<ol>
<li>volatile是线程同步的轻量级实现，性能好于synchronized。但随着JDK的发展，synchronized执行效率得到很大的提升。</li>
<li>volatile只能修饰变量。synchronized可以修饰方法和代码块。</li>
<li>多线程访问volatile不会阻塞，而synchronized相反。</li>
<li>volatile可以保证数据的可见性，但是不能保证原子性。synchronized可以保证原子性，因此也可以保证可见性。</li>
<li>volatile解决的是变量在多个线程的可见性，而synchronized解决的是多个线程访问资源的同步性。</li>
</ol>
<p>volatile关键字的 <strong> 应用场景 </strong> ：主要是在多个线程感知实例变量更改，可以获得最新的值使用。</p>
<h3 id="原子类进行i-操作"><a href="#原子类进行i-操作" class="headerlink" title="原子类进行i++操作"></a>原子类进行i++操作</h3><p>i++貌似一句话，但实际上在虚拟机内部分解为几段代码，分别增加、赋值。因此，对于自增语句，volatile并不能保证线程安全。这种情况下，可以使用原子类来实现功能。<br>一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_12AtomicInteger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread[] threadArr = <span class="keyword">new</span> MyThread[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (Thread t : threadArr) &#123;</span><br><span class="line">			t = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">				System.out.println(count.incrementAndGet());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子类也不能保证完全正确"><a href="#原子类也不能保证完全正确" class="headerlink" title="原子类也不能保证完全正确"></a>原子类也不能保证完全正确</h3><p>原子类（或者别的线程安全的类）只能保证自己的语句原子（或同步）执行，如果不加锁，语句和语句之间仍不同步。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/Java多线程编程-二.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Java多线程编程(二)
        
      </div>
    </a>
  
  
    <a href="/java求绝对值的一个小bug.html" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">java求绝对值的一个小bug</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Java多线程编程-一" data-title="Java多线程编程(一)" data-url="http://Minwell1992.github.io/Java多线程编程-一.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"minwell1992"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Minwell
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>