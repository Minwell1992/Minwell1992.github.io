<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-archives-icon" class="nav-icon" href="/archives"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java多线程编程-三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2016/06/17/Java多线程编程-三/">Java多线程编程(三)</a>
  

      </header>
    
    <time class="article-date" datetime="2016-06-17T12:45:26.000Z" itemprop="datePublished">06-17-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/17/Java多线程编程-三/" data-id="cipjqb7x50000y4jerx24fgv3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程编程-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2016/06/15/Java多线程编程-二/">Java多线程编程(二)</a>
  

      </header>
    
    <time class="article-date" datetime="2016-06-15T07:44:20.000Z" itemprop="datePublished">06-15-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>使用线程的场景很多，线程间通信是线程互相协作的必要技术。</p>
<h2 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h2><p>wait()方法作用是使当前执行代码的线程进行等待。该方法是object方法，将当前线程放入“预执行队列”中，并在wait()处停止，直到接到通知或中断为止。调用wait()前，线程必须 <strong> 要获得该对象的对象级别锁 </strong> —— <strong> 只能在同步方法或同步代码块 </strong> 调用此方法。执行方法后，当前线程释放锁。如果调用wait()时没有得到合适的锁，就会抛出IllegalMonitorStateException(RuntimeException)异常。<br>notify()方法作用是 <strong> 对象 </strong> 通知等待的线程继续运行。若有多个线程等待，线程规划器随机挑选一个wait线程唤醒。与wait()类似，也必须持有对象的锁。需要注意的是，notify()方法执行后并未立刻释放锁，而且等待线程也不是立即被唤醒，而是在当前线程执行完毕，也就是退出synchronized代码块后当前线程才会释放锁，wait线程才可以获取锁。<br>总而言之，wait使线程停止运行，notify使停止的线程继续运行。<br>一个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3SimpleWaitNotify</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Object o = <span class="keyword">new</span> Object();</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA(o);</span><br><span class="line">		a.start();</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThreadB(o);</span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		b.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Object o;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.o = o;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">					System.out.println(<span class="string">"start wait time is "</span> + System.currentTimeMillis());</span><br><span class="line">					o.wait();</span><br><span class="line">					System.out.println(<span class="string">"end wait time is "</span> + System.currentTimeMillis());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Object o;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadB</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.o = o;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">				System.out.println(<span class="string">"start notify time is "</span> + System.currentTimeMillis());</span><br><span class="line">				o.notify();</span><br><span class="line">				System.out.println(<span class="string">"end notify time is "</span> + System.currentTimeMillis());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="interrupt-和wait"><a href="#interrupt-和wait" class="headerlink" title="interrupt()和wait()"></a>interrupt()和wait()</h3><p>当线程正在等待，调用线程对象的interrupt()方法时会出现InterruptedException。<br>总结一下线程释放锁的3种情况：</p>
<ol>
<li>执行完同步代码块就会释放对象的锁；</li>
<li>执行代码块时遇到异常而线程终止，也会释放锁；</li>
<li>执行wait()方法，线程释放锁后进入线程等待池等待被唤醒。</li>
</ol>
<h3 id="wait-long-timeout-方法"><a href="#wait-long-timeout-方法" class="headerlink" title="wait(long timeout)方法"></a>wait(long timeout)方法</h3><p>等待timeout毫秒时间内是否有线程对锁进行唤醒，超时自动唤醒。<br>观察源码，wait()其实就是wait(0)。</p>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p>生产者消费者是经典多线程问题。如果处理不好生产者和消费者的关系，很容易使系统进入假死状态，即两者都在无限等待，谁也不能执行。可以灵活的使用操作栈来执行业务逻辑。使用wait()和notify()方法可以写出合适的例子。但是这种方式对编程水平要求很高，需要避免假死。可以使用并发包里合适的类来编程。</p>
<h3 id="管道线程通信"><a href="#管道线程通信" class="headerlink" title="管道线程通信"></a>管道线程通信</h3><p>管道流(pipeStream)是一种特殊的流，用于在不同线程间传送数据。一个线程发送输入管道，一个线程在管道另一端接受数据。通过使用管道，可以实现不同线程间的通信，而无须借助类似临时文件之类的数据结构。<br>有两种管道，分别对应字节流和字符流：</p>
<ul>
<li>PipedInputStream &amp; PipedOutputStream</li>
<li>PipedReader &amp; PipedWriter</li>
</ul>
<p>管道通信IO流与常规IO流用法基本一样。下面是一个小例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_7TestPipe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		WriteData writeData = <span class="keyword">new</span> WriteData();</span><br><span class="line">		ReadData readData = <span class="keyword">new</span> ReadData();</span><br><span class="line">		PipedInputStream in = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">		PipedOutputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">		in.connect(out);</span><br><span class="line">		Thread readThread = <span class="keyword">new</span> MyThreadA(writeData, out);</span><br><span class="line">		Thread writeThread = <span class="keyword">new</span> MyThreadB(readData, in);</span><br><span class="line">		readThread.start();</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		writeThread.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span> <span class="params">(PipedOutputStream out)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"write:"</span>);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>;i++)&#123;</span><br><span class="line">					String outData = <span class="string">""</span> + (i + <span class="number">1</span>);</span><br><span class="line">					out.write(outData.getBytes());</span><br><span class="line">					System.out.println(outData);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println();</span><br><span class="line">				out.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span> <span class="params">(PipedInputStream in)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"read:"</span>);</span><br><span class="line">				<span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">40</span>];</span><br><span class="line">				<span class="keyword">int</span> readLength = in.read(byteArray);</span><br><span class="line">				<span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</span><br><span class="line">					String str = <span class="keyword">new</span> String(byteArray, <span class="number">0</span>, readLength);</span><br><span class="line">					System.out.println(str);</span><br><span class="line">					readLength = in.read(byteArray);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println();</span><br><span class="line">				in.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> WriteData write;</span><br><span class="line">		<span class="keyword">private</span> PipedOutputStream out;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(WriteData write, PipedOutputStream out)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.write = write;</span><br><span class="line">			<span class="keyword">this</span>.out = out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			write.writeMethod(out);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> ReadData read;</span><br><span class="line">		<span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadB</span><span class="params">(ReadData read, PipedInputStream in)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.read = read;</span><br><span class="line">			<span class="keyword">this</span>.in = in;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			read.readMethod(in);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要使用字符流，只需将InputStream变成Reader，OutputStream变成Writer。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>方法join()的作用是使所述线程对象x能正常执行run()方法中的任务，而使当前线程z进行无限期的阻塞，直到x销毁后再执行线程z后面的代码。join使线程排队运行，类似同步的效果。join与synchronized的区别是：join内部使用wait()进行等待，而synchronized使用“对象监视器”原理进行同步。<br>join()的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">			wait(<span class="number">0</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">			<span class="keyword">long</span> delay = millis - now;</span><br><span class="line">			<span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			wait(delay);</span><br><span class="line">			now = System.currentTimeMillis() - base;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此可见，join(long millis)方法语义是等待当前线程结束后或者等待millis时间后停止等待。如果当线程join()时被中断会抛出InterruptedException。<br>join()和sleep()的区别：</p>
<ol>
<li>join()最多等待xx时间，如果当前线程执行完毕，那么会立即执行；sleep()则是死等xx时间。</li>
<li>join()内部调用wait()方法，释放锁，而sleep()不会释放锁。</li>
</ol>
<h2 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h2><p>ThreadLocal类解决的是变量在不同线程间的隔离性，也就是不同线程永远自己的值，不同线程可以将值放入ThreadLocal类中保存。可以将其比作全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<h3 id="ThreadLocal类的使用"><a href="#ThreadLocal类的使用" class="headerlink" title="ThreadLocal类的使用"></a>ThreadLocal类的使用</h3><p>ThreadLocal用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA();</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThreadB();</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">			TLUtil.tl.set(<span class="string">"Main"</span> + (i + <span class="number">1</span>));</span><br><span class="line">			System.out.println(<span class="string">"Main get value="</span> + TLUtil.tl.get());</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//static ThreadLocal variable</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TLUtil</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">					TLUtil.tl.set(<span class="string">"ThreadA"</span> + (i + <span class="number">1</span>));</span><br><span class="line">					System.out.println(<span class="string">"ThreadA getValue="</span> + TLUtil.tl.get());</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">					TLUtil.tl.set(<span class="string">"ThreadB"</span> + (i + <span class="number">1</span>));</span><br><span class="line">					System.out.println(<span class="string">"ThreadB getValue="</span> + TLUtil.tl.get());</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将ThreadLocal变量放在静态工厂中，供别的程序存取。通过这个例子可以看出，ThreadLocal变量确实是在每一个线程中有自己的副本。</p>
<h3 id="深入理解ThreadLocal类"><a href="#深入理解ThreadLocal类" class="headerlink" title="深入理解ThreadLocal类"></a>深入理解ThreadLocal类</h3><p>ThreadLocal类是java.lang包中的类，足以表示他的重要性了。最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。这些场景创建一次连接效率很低，创建副本明显比内部新建要好得多。<br>下面从源码来学习ThreadLocal。<br>首先是ThreadLocal的功能方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。<br>来看一下ThreadLocal是如何为每一个线程创建副本。<br>get方法的实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value in the current thread's copy of this</span><br><span class="line"> * thread-local variable.  If the variable has no value for the</span><br><span class="line"> * current thread, it is first initialized to the value returned</span><br><span class="line"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先取得当前线程的引用，然后通过getMap(t)方法取得一个ThreadLocalMap内部类对象map。接着，取到<key,value>键值对， <strong> 注意这里获取键值对传进去的是this，而不是当前线程t </strong> 。若获取成功，返回value。如果map为空，调用setInitialValue()方法返回value。接着沿着脉络向下分析getMap(t)的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Get the map associated with a ThreadLocal. Overridden in</span><br><span class="line"> * InheritableThreadLocal.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span>  t the current thread</span><br><span class="line"> * <span class="doctag">@return</span> the map</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></key,value></p>
<p>getMap()方法返回的是当前线程的threadLocals变量。顺藤摸瓜：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>实际上指向ThreadLocal的内部类ThreadLocalMap。接下来看一看ThreadLocalMap的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The entries in this hash map extend WeakReference, using</span><br><span class="line">     * its main ref field as the key (which is always a</span><br><span class="line">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="line">     * == null) mean that the key is no longer referenced, so the</span><br><span class="line">     * entry can be expunged from table.  Such entries are referred to</span><br><span class="line">     * as "stale entries" in the code that follows.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>内部类ThreadLocalMap中还嵌套内部类Entry，而且继承自WeakReference，使用ThreadLocal作为键，Object作为值。<br>继续看setInitialValue()方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Variant of set() to establish initialValue. Used instead</span><br><span class="line"> * of set() in case user has overridden the set() method.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> the initial value</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先在initialValue()中取得设置的起始值，若不重写initialValue()方法，那么就会返回null。如果键不为空，那么设置键值对(this, value)，并返回value；否则，调用createMap(t, value)方法。下面来看createMap(t, value)的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create the map associated with a ThreadLocal. Overridden in</span><br><span class="line"> * InheritableThreadLocal.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> t the current thread</span><br><span class="line"> * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="line"> * <span class="doctag">@param</span> map the map to store.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们已经可以明白ThreadLocal类是如何为每个线程创建副本：</p>
<ul>
<li>Thread类有一个ThreadLocalMap类型变量threadLocals， <strong> 实际的变量副本正是在此保存 </strong> 。</li>
<li>初始Thread的threadLocals为null，调用get()或set()方法后就会对其初始化，以当前ThreadLocal为键，以initialValue()返回值为值。</li>
<li>当前线程可以通过get()方法来获取当前线程的值。</li>
</ul>
<p>总结一下：</p>
<ol>
<li>实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</li>
<li>threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量.</li>
<li>在进行get之前，必须先set，否则会报空指针异常，如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。</li>
</ol>
<blockquote>
<p>ThreadLocal部分参考<a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></p>
</blockquote>
<h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><p>可以使用synchronized关键字实现线程的同步互斥，但java.util.concurrent.locks包中的类也能达到同样的效果，并且在扩展功能上也更加强大，具有嗅探锁定、多路分支通知等功能，而且更加灵活。例如，可以设定超时自动释放锁，“读”不加锁而“写”上锁这样的逻辑功能。但需要注意：</p>
<ol>
<li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li>
<li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li>
</ol>
<h2 id="Lock分析"><a href="#Lock分析" class="headerlink" title="Lock分析"></a>Lock分析</h2><p>查看源码知，Lock是一个接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这几个方法中，lock()、lockInterruptibly()、tryLock()、tryLock(long time, TimeUnit unit)是获取锁，unLock()方法是用来释放锁的。</p>
<ol>
<li><p>lock()使用得最多的一个方法, 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁。一般用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    <span class="comment">//异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryLock(),尝试获取锁，如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false。这个方法不会等待，直接返回。</p>
</li>
<li><p>tryLock(long timeout,TimeUnit unit),如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false。一般tryLock方法是这样使用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够 <strong> 响应中断 </strong> ，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
</li>
</ol>
<h2 id="ReetrantLock重入锁"><a href="#ReetrantLock重入锁" class="headerlink" title="ReetrantLock重入锁"></a>ReetrantLock重入锁</h2><p>ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了锁投票，定时锁等候和中断锁等候。线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用synchronized，如果A不释放，B将一直等下去，不能被中断。如果使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情。<br>需要 <strong> 注意 </strong> 的是，synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就 <strong> 必须将unLock()放到finally{}中 </strong> 。<br>关于性能的问题，在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态。但是，Lock锁需要手动管理，对编程技巧要求较高。我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。<br>Lock()的使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，必须在类中定义锁对象，这样在方法中才能正确执行锁操作。因为如果在方法中定义，那么每个线程自己锁住自己，没有实现我们想要的功能。<br>tryLock()的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"获取锁失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lockInterruptibly()响应中断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</span><br><span class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//插入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行finally"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Condition来控制线程等待or唤醒"><a href="#Condition来控制线程等待or唤醒" class="headerlink" title="Condition来控制线程等待or唤醒"></a>Condition来控制线程等待or唤醒</h2><p>类似于wait()和notify()，lock也有相应的机制来控制线程。wait()和notify()分别对应await()和signal()。Condition用法示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3TestCondition</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> _3TestCondition tc = <span class="keyword">new</span> _3TestCondition();</span><br><span class="line">		<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				tc.await();</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				tc.singal();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			System.out.println(<span class="string">"begin wait"</span>);</span><br><span class="line">			condition.await();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"stop wait"</span>);</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			condition.signal();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"send signal"</span>);</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。<br>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>此外，ReentrantLock还有一些别的工具方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getHoldCount()			<span class="comment">//查询当前线程保持此锁的个数，也就是调用lock()的次数</span></span><br><span class="line">hasQueuedThread(Thread thread)<span class="comment">//是否有线程正在等待此锁定</span></span><br><span class="line">getQueueLength()		<span class="comment">//返回正在等待此锁定线程的个数</span></span><br><span class="line">isFair()				<span class="comment">//判断锁是否是公平锁</span></span><br><span class="line">isHeldByCurrentThread()	<span class="comment">//是否被当前线程锁定</span></span><br><span class="line">isLocked()				<span class="comment">//判断锁是否被任何线程获取了</span></span><br><span class="line">isHeldByCurrentThread()	<span class="comment">//判断锁是否被当前线程获取了</span></span><br><span class="line">hasQueuedThreads()		<span class="comment">//判断是否有线程在等待该锁</span></span><br></pre></td></tr></table></figure></p>
<h2 id="ReentrantReadWriteLock类"><a href="#ReentrantReadWriteLock类" class="headerlink" title="ReentrantReadWriteLock类"></a>ReentrantReadWriteLock类</h2><p>ReentrantLock可以说是synchronize的解耦，完全互斥排他。这样做可以保持线程安全性，但效率非常低下。ReentrantReadWriteLock类进一步解耦，提高效率。读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作锁，也叫排它锁。共享锁不互斥，而排它锁互斥。<br>需要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_4ReentrentRWL</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> _4ReentrentRWL rrwl = <span class="keyword">new</span> _4ReentrentRWL();</span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				rrwl.get();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				rrwl.get();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		rwl.readLock().lock();</span></span><br><span class="line">		rwl.writeLock().lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"go in get()"</span>);</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"go out of get()"</span>);</span><br><span class="line"><span class="comment">//			rwl.readLock().unlock();</span></span><br><span class="line">			rwl.writeLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结来说，Lock和synchronized有以下几点不同：</p>
<ol>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。</li>
</ol>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<blockquote>
<p><a href="http://houlinyan.iteye.com/blog/1112535" target="_blank" rel="external">Lock与synchronized 的区别</a><br><a href="http://www.cnblogs.com/dolphin0520/p/3923167.html#3453660" target="_blank" rel="external">Java并发编程：Lock</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/15/Java多线程编程-二/" data-id="cipjqb7xh0002y4jejycjrre2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程编程-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2016/06/13/Java多线程编程-一/">Java多线程编程(一)</a>
  

      </header>
    
    <time class="article-date" datetime="2016-06-13T12:12:46.000Z" itemprop="datePublished">06-13-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&gt;《java并发编程实践》（理论掌握）-&gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。<br>下面就记录一下我的一些心得体会：</p>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>这个是基础中的基础啦，两种方式，最好选择实现接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_1CreateNewThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">super</span>.run();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">					System.out.println(<span class="string">"MyThread1"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">					System.out.println(<span class="string">"MyThread2"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程启动顺序与调用start()方法顺序无关。</span><br></pre></td></tr></table></figure></p>
<h2 id="一个典型线程不安全例子"><a href="#一个典型线程不安全例子" class="headerlink" title="一个典型线程不安全例子"></a>一个典型线程不安全例子</h2><p>这个例子中，对变量a设置了延迟，导致必然出现线程不安全。加锁就可以恢复正常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3ThreadSafe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ALogin a = <span class="keyword">new</span> ALogin();</span><br><span class="line">		BLogin b = <span class="keyword">new</span> BLogin();</span><br><span class="line">		a.start(); b.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> String userNameRef;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> String passWordRef;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPost</span> <span class="params">(String userName, String passWord)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				userNameRef = userName;</span><br><span class="line">				<span class="keyword">if</span> (userName.equals(<span class="string">"a"</span>))</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				passWordRef = passWord;</span><br><span class="line">				System.out.println(<span class="string">"username="</span> + userNameRef + </span><br><span class="line">						<span class="string">" password="</span> + passWordRef);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ALogin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			LoginServlet.doPost(<span class="string">"a"</span>, <span class="string">"aa"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BLogin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			LoginServlet.doPost(<span class="string">"b"</span>, <span class="string">"bb"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，在main方法中，只能实现静态内部类或者非静态成员内部类。而静态类也有很多的坑，比如私有构造方法无效，可以new，等等。</p>
<h2 id="syso与i–"><a href="#syso与i–" class="headerlink" title="syso与i–"></a>syso与i–</h2><p>syso方法是线程安全的，源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    print(x);</span><br><span class="line">	    newLine();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，要小心其中的i–：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_4SumNum</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread run = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t4 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t5 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">		t5.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.currentThread().getName() + <span class="string">" i="</span> + i--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，可以发现有一定的概率会出现线程安全问题。这是因为println()方法内在同步，但是i–的操作是进入方法前完成的，所以有几率发生问题。</p>
<h2 id="几个常用方法"><a href="#几个常用方法" class="headerlink" title="几个常用方法"></a>几个常用方法</h2><h3 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h3><p>currentThread()方法返回代码段正在被哪个线程调用的信息，API的原文是</p>
<pre><code>Returns a reference to the currently executing thread object.
</code></pre><p>若不重写Thread方法，此时this.currentThread()跟Thread.currentThread()无任何区别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_5CurrentThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> CountOperate();</span><br><span class="line">		t1.setName(<span class="string">"ThreadA"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountOperate</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">CountOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"CountOperate--begin"</span>);</span><br><span class="line">			System.out.println(<span class="string">"current thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"this.getName():"</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">			System.out.println(<span class="string">"CountOperate--end"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"run--begin"</span>);</span><br><span class="line">			System.out.println(<span class="string">"current thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"this.getName():"</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">			System.out.println(<span class="string">"run--end"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>CountOperate--begin
current thread:main
this.getName():Thread-0
CountOperate--end
run--begin
current thread:ThreadA
this.getName():ThreadA
run--end
</code></pre><p>可以看到，Thread.currentThread()是main线程，this是当前线程。</p>
<h3 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h3><p>isAlive()方法表示当前线程是否为活动状态，即线程已启动，且未终止的状态。API中的原文是：</p>
<pre><code>Tests if this thread is alive. A thread is alive if it has been started and has not yet died.
</code></pre><h3 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h3><p>表示当前线程睡眠n个ms。需要检查异常InterrupttedException。<br>有一个很重要的知识点，同样是等待，sleep()和wait()的区别是什么呢？sleep()睡眠，但是并不释放锁。而wait()将锁释放，表示当前线程正在等待，只有notify()方法被调用后才会醒来。<br>此外，最好使用TimeUnit.··.sleep()方法来替代sleep()方法。因为sleep()只能表示ms，而TimeUnit类可以直观的表示睡眠了多少m，s，ms，ns，等，可读性很强。</p>
<h3 id="getId-方法"><a href="#getId-方法" class="headerlink" title="getId()方法"></a>getId()方法</h3><p>获取线程唯一标识。并不可以通过setId()来设置其id。观察其源码，发现id是内部生成的，作为其标识。</p>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>需要有技巧的安全的停止线程。主要有3个方法，后文将详细介绍。</p>
<ol>
<li>使用退出标志，正常退出，即run方法完成后线程终止；</li>
<li>stop()方法强制退出(这种方式已废弃)；</li>
<li>interrupt()方法中断线程。并不会强制终止，而是传入中断信号，还需要线程配合判断才能真正的终止。</li>
</ol>
<h3 id="interrupted-和isInterrupted"><a href="#interrupted-和isInterrupted" class="headerlink" title="interrupted()和isInterrupted()"></a>interrupted()和isInterrupted()</h3><p>两个方法的源码声明如下，可以发现非常的相像：</p>
<pre><code>public boolean isInterrupted() {}
public static boolean interrupted() {}
</code></pre><p>两者的区别：</p>
<ul>
<li>this.interrupted():测试当前是否中断，执行后将标志重置为false；</li>
<li>this.isInterrupted():测试线程Thread对象是否是中断状态，不清除标志位。</li>
</ul>
<p>利用中断可以灵活的终止线程,if (this.interrupted())来检测</p>
<ul>
<li>仅仅跳出循环，可以检测时break；</li>
<li>若需要退出线程，抛出InterrupttedException异常，并检测即可；</li>
<li>也可以使用return来退出，但不如异常方式，因为可以一层一层向上抛出。</li>
</ul>
<p>若处于睡眠，进行中断则会进入InterrupttedException异常中。需要注意的是，无论睡眠与否，若中断打开，那么都会抛出异常。</p>
<h3 id="暂停线程suspend和resume方法"><a href="#暂停线程suspend和resume方法" class="headerlink" title="暂停线程suspend和resume方法"></a>暂停线程suspend和resume方法</h3><p>与stop一样都是被废除的方法。使用不当极易造成公共对象独占，导致死锁。而且还有不同步等缺点。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>作用是放弃当前cpu资源，让给逼得资源。但放弃的时间不确定，有可能刚刚放弃，马上又获得了时间片。<br>在测试yield的方法时，发现电脑循环500w后用时2ms？然后循环5000w后还是2ms？实验室的电脑性能只能说一般，一定是哪里有问题。这个问题先搁置，以后有空解决下。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>不能依赖java中的优先级。优先级还是取决于系统，有些系统根本就不认可java的优先级。设置方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(n)</span><br></pre></td></tr></table></figure></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>java中有两种线程，一种是用户线程，一种是守护线程。<br>守护线程是一种特殊的线程，我理解为“保姆”线程。典型的守护线程就是垃圾回收线程。当进程中没有非守护线程，那么垃圾回收线程也就没有必要了，自动销毁。守护线程的存在意义就是被守护线程。<br>设置方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="关键字synchronized-和-volatile"><a href="#关键字synchronized-和-volatile" class="headerlink" title="关键字synchronized 和 volatile"></a>关键字synchronized 和 volatile</h1><p>java中与同步相关的主要就是这两个关键字，下面来研究研究。</p>
<h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><p>syncronized意思是同步，相对应异步是asyncronized。syncronized为重量级锁，安全但是比较笨重。</p>
<h3 id="私有变量线程安全"><a href="#私有变量线程安全" class="headerlink" title="私有变量线程安全"></a>私有变量线程安全</h3><p>私有变量作用域仅在方法内部，因此不存在线程安全问题。而成员变量在方法外部，会产生竞争使用的问题，有可能线程不安全。</p>
<h3 id="对象与锁"><a href="#对象与锁" class="headerlink" title="对象与锁"></a>对象与锁</h3><p>synchronized是对象锁，锁住的是对象，而不是代码。因此，对于不同的对象，每个对象有自己的锁。只有共享的资源才需要同步，若不是共享资源，那么根本没有同步的必要。<br>此外，在对象内部，若A先持有对象的锁，那么B可以异步调用对象的非synchronized方法；而B调用synchronized方法时则需要等待A释放锁。代码运行结果清晰地表示出来这个特性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_2LockObject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyObject o = <span class="keyword">new</span> MyObject();</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA(o);</span><br><span class="line">		a.setName(<span class="string">"A"</span>);</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThreadB(o);</span><br><span class="line">		b.setName(<span class="string">"B"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"Begin method is "</span> + Thread.currentThread().getName());</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(<span class="string">"End time "</span> + System.currentTimeMillis());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//add lock</span></span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"Begin method is "</span> + Thread.currentThread().getName()</span><br><span class="line">						+ <span class="string">" Begin time is "</span> + System.currentTimeMillis());</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(<span class="string">"End"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> MyObject object; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(MyObject object)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.object = object;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			object.methodA();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> MyObject object; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadB</span><span class="params">(MyObject object)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.object = object;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			object.methodB();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="脏读-dirty-read"><a href="#脏读-dirty-read" class="headerlink" title="脏读(dirty read)"></a>脏读(dirty read)</h3><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还未同步，这时，另外一个事务也访问这个数据，然后使用了这个数据。下面这个例子中，getValue()先于setValue()执行完毕，此时setValue()执行了一半，数据未完全同步，因此会调用出错，出现脏读。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3DirtyRead</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		PublicVar p = <span class="keyword">new</span> PublicVar();</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA(p);</span><br><span class="line">		a.start();</span><br><span class="line">		Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		p.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PublicVar</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> String username = <span class="string">"A"</span>;</span><br><span class="line">		<span class="keyword">public</span> String password = <span class="string">"AA"</span>;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.username = username;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="keyword">this</span>.password = password;</span><br><span class="line">				System.out.println(<span class="string">"setValue thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">				System.out.println(<span class="string">"username:"</span> + username + <span class="string">" password:"</span> + password);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		dirty read</span></span><br><span class="line"><span class="comment">//		synchronized</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"getValue thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"username:"</span> + username + <span class="string">" password:"</span> + password);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> PublicVar publicVar; </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(PublicVar publicVar)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.publicVar = publicVar;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			publicVar.setValue(<span class="string">"B"</span>, <span class="string">"BB"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h3><p>锁重入指的是持有锁的线程试图获得锁时，请求会成功。换种说法，就是再一个synchronized方法内部调用本类其他synchronized方法时，永远会拿到锁。更为规范的<a href="http://ifeve.com/java_lock_see4/" target="_blank" rel="external">说法</a>是这样的：</p>
<blockquote>
<p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。</p>
</blockquote>
<p>举个栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_4LockIn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"service1"</span>);</span><br><span class="line">			service2();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"service2"</span>);</span><br><span class="line">			service3();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"service3"</span>);</span><br><span class="line"><span class="comment">//			service1();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			Service service = <span class="keyword">new</span> Service();</span><br><span class="line">			service.service1();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，service1()调用锁上的service2()，又调用service3()。印证了可以递归调用这一说法。<br>可重入锁最大的作用是避免死锁。以自旋锁作为例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, current))&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于自旋锁来说，</p>
<ol>
<li>若有同一线程两调用lock() ，会导致第二次调用lock位置进行自旋，产生了死锁。说明这个锁并不是可重入的。（在lock函数内，应验证线程是否为已经获得锁的线程）</li>
<li>若1问题已经解决，当unlock（）第一次调用时，就已经将锁释放了。实际上不应释放锁。（采用计数次进行统计）</li>
</ol>
<p>设置标志位count，重入时+1，释放时-1。修改之后，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock1</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner =<span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span>(current==owner.get()) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, current))&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span>(current==owner.get())&#123;</span><br><span class="line">			<span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">				count--;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				owner.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该自旋锁即为可重入锁。<br>此外，可重入锁也支持父子类继承的环境中，子类可以通过可重入锁来调用父类的同步方法。</p>
<h3 id="锁与异常"><a href="#锁与异常" class="headerlink" title="锁与异常"></a>锁与异常</h3><p>当一个线程代码出现异常时，锁会自动释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_5LockAndExeption</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Service s = <span class="keyword">new</span> Service();</span><br><span class="line">		Thread a = <span class="keyword">new</span> MyThreadA(s);</span><br><span class="line">		a.setName(<span class="string">"a"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		Thread b = <span class="keyword">new</span> MyThreadB(s);</span><br><span class="line">		b.setName(<span class="string">"b"</span>);</span><br><span class="line">		b.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Thread name is "</span>+ Thread.currentThread().getName()</span><br><span class="line">						+ <span class="string">". run beginTime is "</span> + System.currentTimeMillis());</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((<span class="string">""</span> + Math.random()).substring(<span class="number">0</span>, <span class="number">8</span>).equals(<span class="string">"0.123456"</span>)) &#123;</span><br><span class="line">						System.out.println(<span class="string">"ThreadName is "</span> + Thread.currentThread().getName()</span><br><span class="line">								+ <span class="string">". run exceptionTime is "</span> + System.currentTimeMillis());</span><br><span class="line">						Integer.parseInt(<span class="string">"a"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> </span><br><span class="line">				System.out.println(<span class="string">"Thread B runTime is"</span> + System.currentTimeMillis());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Service service;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.service = service;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			service.testMethod();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Service service;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyThreadB</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.service = service;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.run();</span><br><span class="line">			service.testMethod();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="同步不能继承"><a href="#同步不能继承" class="headerlink" title="同步不能继承"></a>同步不能继承</h3><p>当子类重写父类方法的时候，如果不加入同步标志，一样不具备同步性。</p>
<h2 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h2><p>synchronized代码块更加灵活，只将需要同步的对象同步，而别的部分是异步执行。可以既保持同步又提高性能。<br>当一个线程访问synchronized(this)代码块，其他线程对同一个对象中其他synchronized(this)代码块访问将被阻塞。<br>推广来说，synchronized(x)中x可以为任意对象，有以下几个性质：</p>
<ol>
<li>多个线程同时执行synchronized(x){}同步代码块时同步；</li>
<li>其他线程执行x对象内的synchronized同步方法同步；</li>
<li>其他线程执行x对象synchronized(this)代码块同步。</li>
</ol>
<h3 id="String的一些问题"><a href="#String的一些问题" class="headerlink" title="String的一些问题"></a>String的一些问题</h3><p>String对象处于常量池中，同内容对象在内存中只有一份。如果持有String对象的锁，那么很容易造成不同对象持有相同的锁，造成线程同步问题。因此大多数情况下，同步synchronized代码块都不使用String作为锁对象，而改用其他。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile主要有两个作用，分别是可见性与有序性。可见性指的是线程更新变量，所有线程都将更新这个变量。有序性指的是volatile变量代码段不使用重排序功能。<br>volatile实现可见性主要原理是这样的：每次读取该变量，强制从公共内存中读取，更改变量后，又写入公共内存中。但其最大的缺点就是不支持原子性。<br>volatile和synchronized都是同步关键字，有什么不同呢？主要是以下几点：</p>
<ol>
<li>volatile是线程同步的轻量级实现，性能好于synchronized。但随着JDK的发展，synchronized执行效率得到很大的提升。</li>
<li>volatile只能修饰变量。synchronized可以修饰方法和代码块。</li>
<li>多线程访问volatile不会阻塞，而synchronized相反。</li>
<li>volatile可以保证数据的可见性，但是不能保证原子性。synchronized可以保证原子性，因此也可以保证可见性。</li>
<li>volatile解决的是变量在多个线程的可见性，而synchronized解决的是多个线程访问资源的同步性。</li>
</ol>
<p>volatile关键字的 <strong> 应用场景 </strong> ：主要是在多个线程感知实例变量更改，可以获得最新的值使用。</p>
<h3 id="原子类进行i-操作"><a href="#原子类进行i-操作" class="headerlink" title="原子类进行i++操作"></a>原子类进行i++操作</h3><p>i++貌似一句话，但实际上在虚拟机内部分解为几段代码，分别增加、赋值。因此，对于自增语句，volatile并不能保证线程安全。这种情况下，可以使用原子类来实现功能。<br>一个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_12AtomicInteger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread[] threadArr = <span class="keyword">new</span> MyThread[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (Thread t : threadArr) &#123;</span><br><span class="line">			t = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">				System.out.println(count.incrementAndGet());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子类也不能保证完全正确"><a href="#原子类也不能保证完全正确" class="headerlink" title="原子类也不能保证完全正确"></a>原子类也不能保证完全正确</h3><p>原子类（或者别的线程安全的类）只能保证自己的语句原子（或同步）执行，如果不加锁，语句和语句之间仍不同步。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/13/Java多线程编程-一/" data-id="cipjqb7xo0003y4jeors5keeu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java求绝对值的一个小bug" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2016/06/08/java求绝对值的一个小bug/">java求绝对值的一个小bug</a>
  

      </header>
    
    <time class="article-date" datetime="2016-06-08T02:58:52.000Z" itemprop="datePublished">06-08-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>前一段时间泡博客的时候看到了一个有趣的现象，在此记录下来。<br>eclipse中输入下面的语句，猜猜结果会是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.abs(-<span class="number">2147483648</span>));</span><br></pre></td></tr></table></figure></p>
<p>出人意料！结果还是-2147483648！<br>这是为什么呢？那就要从绝对值源码来探索了。Math.abs()的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，仅仅是最简单的判断取反。那对-2147483648意味着什么呢？<br>-2147483648其实是Integer.MIN_VALUE，即int能表示的最小值，二进制表示为1000,0000,0000,0000,0000,0000,0000,0000。而取反操作其实就是反码加1，而这个值的反码为111…，加1后又变为其本身。这个问题的本质原因就是int类型的大小限制，与sun公司没有考虑到这一个下界所共同导致的。<br>那么怎样解决这个问题呢？因为int类型的限制，根本就不可能表示2147483648这个数字，将这个数字转换为long类型才可以正常使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.abs(-<span class="number">2147483648L</span>));</span><br></pre></td></tr></table></figure></p>
<p>那么到达long类型的上界又怎么办呢？此时可以借助BigInteger这个类来实现我们的需求————而BigInteger类型是解决大数问题最好选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/08/java求绝对值的一个小bug/" data-id="cipjqb7xq0004y4je65kgjzj4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2016/06/06/hello-world/">Hello World</a>
  

      </header>
    
    <time class="article-date" datetime="2016-06-06T08:24:46.318Z" itemprop="datePublished">06-06-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160; &#160; &#160; &#160;欢迎来到我的<a href="minwell1992.github.io">博客</a>！早就听说<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>的鼎鼎大名，但是没有找到合适的连续时间，一直没能重新折腾github博客。今天跟随着先驱们的指引，经过惨不忍睹的折腾，两个多小时后终于跑了起来。下面简单介绍我建站的一些粗浅的经验，欢迎指正~~!</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></li>
<li>Git</li>
<li><a href="http://www.sublimetext.com/3" target="_blank" rel="external">Sublime Text3</a></li>
</ul>
<h2 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h2><p>Node.js和Git安装成功后就可以在git中用npm安装hexo</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>在本地初始化文件夹，E:\hexoblogs，进入所建立的文件夹后初始化。执行代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> e:\hexoblogs</span><br><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>上一步结束后，hexoblogs目录应该是：<br>    .<br>    ├── _config.yml<br>    ├── package.json<br>    ├── scaffolds<br>    ├── source<br>    |   ├── _drafts<br>    |   └── _posts<br>    └── themes<br>然后启动本地Hexo目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p>OK，在浏览器中输入localhost:4000。神奇的事情发生了有木有，一个Hexo站点就已经展示出来了！</p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>开博客的目的就在于此。接下来就是重头戏，创建文章</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"title"</span></span><br></pre></td></tr></table></figure>
<p>layout为指定的布局，默认为post。title就是题目啦！新建的文章的地址在E:\hexoblogs\source_posts。可以使用任意编辑器码字，强烈推荐Sublime，速度超快，炫酷的不行，插件功能强大，码农必备！<br>此外，可以在<a href="http://mahua.jser.me/" target="_blank" rel="external">这里</a>提前验证语法规则。</p>
<h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>Hexo主页虽然很炫酷，但我们不会满足于此。<br><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题列表</a>在此。找到一个喜欢的，进入github页面，复制主题的信息，然后一句话安装主题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/author/themename.git themes/modernist</span><br></pre></td></tr></table></figure>
<p>其中，author为作者，themename为主题名。<br>安装成功后，打开hexo_config.yml，修改主题：</p>
<pre><code>theme:modernist
</code></pre><p>更新主题(modernist为示例，即刚下载的主题)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/modernist</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></p>
<p>好了，到此我们完成了对本地Hexo的安装和配置。</p>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h3 id="配置github仓库"><a href="#配置github仓库" class="headerlink" title="配置github仓库"></a>配置github仓库</h3><p>新建一个仓库：Minwell1992.github.io。其中后面两个不能改变，能自由发挥的就是前面的花名，起一个像我这么酷的名字吧~:)<br>配置SSH。在此不再赘述。如果你对关于git和github的相关知识还不是很熟悉，推荐去<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰大大的博客</a>来系统的学习一下，个人觉得非常非常的棒！</p>
<h3 id="配置本地Hexo"><a href="#配置本地Hexo" class="headerlink" title="配置本地Hexo"></a>配置本地Hexo</h3><p>打开Hexo目录下的_config.yml，拉倒最下面<br>配置为这样子,只需要把我的名字改为你的github用户名就可以了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Minwell1992/Minwell1992.github.io.git</span><br></pre></td></tr></table></figure></p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>文章写好后直接执行命令即可发布文章：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure></p>
<p>我在发布的时候出现了错误：</p>
<pre><code>ERROR Deployer not found: git
</code></pre><p>找到了相关资料，执行这句话就ok：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><h2 id="Succeed"><a href="#Succeed" class="headerlink" title="Succeed!"></a>Succeed!</h2><p>好啦！至此一个博客已经粗略的建立起来。虽然看起来挺简陋的，但万事开头难嘛，咱们把框架搭起来了，剩下的就是修修补补的小事了。小事包括：上传图片、更改域名、增加评论分享功能···发挥你的聪明才智，加油咯~~</p>
<blockquote>
<p>参考资料：<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo官网</a><br><a href="http://vimersu.win/blog/2014/03/03/use-hexo-blog/" target="_blank" rel="external">使用Hexo搭建个人博客</a><br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a><br><a href="http://blog.csdn.net/u011116672/article/details/51160742" target="_blank" rel="external">Hexo系列1：从零开始搭建hexo博客</a><br><a href="http://lutaf.com/markdown-simple-usage.htm" target="_blank" rel="external">markdown 简明语法</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/06/hello-world/" data-id="cipjqb7xu0005y4je53dk109r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      <a href="https://github.com/steven5538/hexo-theme-athena" target="_blank">Athena</a> by <a href="http://steven5538.tw" target="_blank">Steven5538</a> | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>