<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java多线程编程(一) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&amp;gt;《java并发编程实践》（理论掌握）-&amp;gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。下面就记录一下我的一些心得体会：
线程基础创建线程这个是基础中的基础啦，两种方式，最好选择实现接口：123456789101112131415161718">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程编程(一)">
<meta property="og:url" content="http://yoursite.com/2016/06/13/Java多线程编程-一/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&amp;gt;《java并发编程实践》（理论掌握）-&amp;gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。下面就记录一下我的一些心得体会：
线程基础创建线程这个是基础中的基础啦，两种方式，最好选择实现接口：123456789101112131415161718">
<meta property="og:updated_time" content="2016-06-13T14:54:38.146Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程编程(一)">
<meta name="twitter:description" content="最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&amp;gt;《java并发编程实践》（理论掌握）-&amp;gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。下面就记录一下我的一些心得体会：
线程基础创建线程这个是基础中的基础啦，两种方式，最好选择实现接口：123456789101112131415161718">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-archives-icon" class="nav-icon" href="/archives"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java多线程编程-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java多线程编程(一)
    </h1>
  

      </header>
    
    <time class="article-date" datetime="2016-06-13T12:12:46.000Z" itemprop="datePublished">06-13-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在学习并发编程。准备学习路线是：《java多线程核心编程技术》（敲一遍）-&gt;《java并发编程实践》（理论掌握）-&gt;java.util.concurrent源码阅读。我将已经敲过的代码放入github仓库中，有兴趣的童鞋可以瞅瞅。<br>下面就记录一下我的一些心得体会：</p>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>这个是基础中的基础啦，两种方式，最好选择实现接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_1CreateNewThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">super</span>.run();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">					System.out.println(<span class="string">"MyThread1"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">					System.out.println(<span class="string">"MyThread2"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="一个典型线程不安全例子"><a href="#一个典型线程不安全例子" class="headerlink" title="一个典型线程不安全例子"></a>一个典型线程不安全例子</h2><p>这个例子中，对变量a设置了延迟，导致必然出现线程不安全。加锁就可以恢复正常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3ThreadSafe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ALogin a = <span class="keyword">new</span> ALogin();</span><br><span class="line">		BLogin b = <span class="keyword">new</span> BLogin();</span><br><span class="line">		a.start(); b.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> String userNameRef;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> String passWordRef;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPost</span> <span class="params">(String userName, String passWord)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				userNameRef = userName;</span><br><span class="line">				<span class="keyword">if</span> (userName.equals(<span class="string">"a"</span>))</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				passWordRef = passWord;</span><br><span class="line">				System.out.println(<span class="string">"username="</span> + userNameRef + </span><br><span class="line">						<span class="string">" password="</span> + passWordRef);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ALogin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			LoginServlet.doPost(<span class="string">"a"</span>, <span class="string">"aa"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BLogin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			LoginServlet.doPost(<span class="string">"b"</span>, <span class="string">"bb"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，在main方法中，只能实现静态内部类或者非静态成员内部类。而静态类也有很多的坑，比如私有构造方法无效，可以new，等等。</p>
<h2 id="syso与i–"><a href="#syso与i–" class="headerlink" title="syso与i–"></a>syso与i–</h2><p>syso方法是线程安全的，源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    print(x);</span><br><span class="line">	    newLine();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，要小心其中的i–：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_4SumNum</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread run = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t4 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t5 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">		t4.start();</span><br><span class="line">		t5.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.currentThread().getName() + <span class="string">" i="</span> + i--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，可以发现有一定的概率会出现线程安全问题。这是因为println()方法内在同步，但是i–的操作是进入方法前完成的，所以有几率发生问题。</p>
<h2 id="几个常用方法"><a href="#几个常用方法" class="headerlink" title="几个常用方法"></a>几个常用方法</h2><h3 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h3><p>currentThread()方法返回代码段正在被哪个线程调用的信息，API的原文是</p>
<pre><code>Returns a reference to the currently executing thread object.
</code></pre><p>若不重写Thread方法，此时this.currentThread()跟Thread.currentThread()无任何区别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_5CurrentThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> CountOperate();</span><br><span class="line">		t1.setName(<span class="string">"ThreadA"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountOperate</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">CountOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"CountOperate--begin"</span>);</span><br><span class="line">			System.out.println(<span class="string">"current thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"this.getName():"</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">			System.out.println(<span class="string">"CountOperate--end"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"run--begin"</span>);</span><br><span class="line">			System.out.println(<span class="string">"current thread:"</span> + Thread.currentThread().getName());</span><br><span class="line">			System.out.println(<span class="string">"this.getName():"</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">			System.out.println(<span class="string">"run--end"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<pre><code>CountOperate--begin
current thread:main
this.getName():Thread-0
CountOperate--end
run--begin
current thread:ThreadA
this.getName():ThreadA
run--end
</code></pre><p>可以看到，Thread.currentThread()是main线程，this是当前线程。</p>
<h3 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h3><p>isAlive()方法表示当前线程是否为活动状态，即线程已启动，且未终止的状态。API中的原文是：</p>
<pre><code>Tests if this thread is alive. A thread is alive if it has been started and has not yet died.
</code></pre><h3 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h3><p>表示当前线程睡眠n个ms。需要检查异常InterrupttedException。<br>有一个很重要的知识点，同样是等待，sleep()和wait()的区别是什么呢？sleep()睡眠，但是并不释放锁。而wait()将锁释放，表示当前线程正在等待，只有notify()方法被调用后才会醒来。<br>此外，最好使用TimeUnit.··.sleep()方法来替代sleep()方法。因为sleep()只能表示ms，而TimeUnit类可以直观的表示睡眠了多少m，s，ms，ns，等，可读性很强。</p>
<h3 id="getId-方法"><a href="#getId-方法" class="headerlink" title="getId()方法"></a>getId()方法</h3><p>获取线程唯一标识。并不可以通过setId()来设置其id。观察其源码，发现id是内部生成的，作为其标识。</p>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>需要有技巧的安全的停止线程。主要有3个方法，后文将详细介绍。</p>
<ol>
<li>使用退出标志，正常退出，即run方法完成后线程终止；</li>
<li>stop()方法强制退出(这种方式已废弃)；</li>
<li>interrupt()方法中断线程。并不会强制终止，而是传入中断信号，还需要线程配合判断才能真正的终止。</li>
</ol>
<h3 id="interrupted-和isInterrupted"><a href="#interrupted-和isInterrupted" class="headerlink" title="interrupted()和isInterrupted()"></a>interrupted()和isInterrupted()</h3><p>两个方法的源码声明如下，可以发现非常的相像：</p>
<pre><code>public boolean isInterrupted() {}
public static boolean interrupted() {}
</code></pre><p>两者的区别：</p>
<ul>
<li>this.interrupted():测试当前是否中断，执行后将标志重置为false；</li>
<li>this.isInterrupted():测试线程Thread对象是否是中断状态，不清除标志位。</li>
</ul>
<p>利用中断可以灵活的终止线程,if (this.interrupted())来检测</p>
<ul>
<li>仅仅跳出循环，可以检测时break；</li>
<li>若需要退出线程，抛出InterrupttedException异常，并检测即可；</li>
<li>也可以使用return来退出，但不如异常方式，因为可以一层一层向上抛出。</li>
</ul>
<p>若处于睡眠，进行中断则会进入InterrupttedException异常中。需要注意的是，无论睡眠与否，若中断打开，那么都会抛出异常。</p>
<h3 id="暂停线程suspend和resume方法"><a href="#暂停线程suspend和resume方法" class="headerlink" title="暂停线程suspend和resume方法"></a>暂停线程suspend和resume方法</h3><p>与stop一样都是被废除的方法。使用不当极易造成公共对象独占，导致死锁。而且还有不同步等缺点。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>作用是放弃当前cpu资源，让给逼得资源。但放弃的时间不确定，有可能刚刚放弃，马上又获得了时间片。<br>在测试yield的方法时，发现电脑循环500w后用时2ms？然后循环5000w后还是2ms？实验室的电脑性能只能说一般，一定是哪里有问题。这个问题先搁置，以后有空解决下。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>不能依赖java中的优先级。优先级还是取决于系统，有些系统根本就不认可java的优先级。设置方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(n)</span><br></pre></td></tr></table></figure></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>java中有两种线程，一种是用户线程，一种是守护线程。<br>守护线程是一种特殊的线程，我理解为“保姆”线程。典型的守护线程就是垃圾回收线程。当进程中没有非守护线程，那么垃圾回收线程也就没有必要了，自动销毁。守护线程的存在意义就是被守护线程。<br>设置方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/13/Java多线程编程-一/" data-id="cipe0h7mj00002gjevvaj5ejx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/06/08/java求绝对值的一个小bug/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java求绝对值的一个小bug</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      <a href="https://github.com/steven5538/hexo-theme-athena" target="_blank">Athena</a> by <a href="http://steven5538.tw" target="_blank">Steven5538</a> | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>