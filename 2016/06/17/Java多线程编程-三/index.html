<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java多线程编程(三) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="定时器Timer定时/计划功能在移动开发领域使用较多，而这个功能主要就是由Timer对象实现的。它在内部使用多线程方式进行处理。下面就来看Timer是如何工作的。
定时器Timer的使用Timer是一个调度器，里面调度的方法TimeTask由自己实现，一个简单的例子如下：123456Timer timer = new Timer();  timer.schedule(new TimerTask()">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程编程(三)">
<meta property="og:url" content="http://yoursite.com/2016/06/17/Java多线程编程-三/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="定时器Timer定时/计划功能在移动开发领域使用较多，而这个功能主要就是由Timer对象实现的。它在内部使用多线程方式进行处理。下面就来看Timer是如何工作的。
定时器Timer的使用Timer是一个调度器，里面调度的方法TimeTask由自己实现，一个简单的例子如下：123456Timer timer = new Timer();  timer.schedule(new TimerTask()">
<meta property="og:updated_time" content="2016-06-21T01:37:43.961Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程编程(三)">
<meta name="twitter:description" content="定时器Timer定时/计划功能在移动开发领域使用较多，而这个功能主要就是由Timer对象实现的。它在内部使用多线程方式进行处理。下面就来看Timer是如何工作的。
定时器Timer的使用Timer是一个调度器，里面调度的方法TimeTask由自己实现，一个简单的例子如下：123456Timer timer = new Timer();  timer.schedule(new TimerTask()">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-archives-icon" class="nav-icon" href="/archives"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java多线程编程-三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java多线程编程(三)
    </h1>
  

      </header>
    
    <time class="article-date" datetime="2016-06-17T12:45:26.000Z" itemprop="datePublished">06-17-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定时器Timer"><a href="#定时器Timer" class="headerlink" title="定时器Timer"></a>定时器Timer</h1><p>定时/计划功能在移动开发领域使用较多，而这个功能主要就是由Timer对象实现的。它在内部使用多线程方式进行处理。下面就来看Timer是如何工作的。</p>
<h2 id="定时器Timer的使用"><a href="#定时器Timer的使用" class="headerlink" title="定时器Timer的使用"></a>定时器Timer的使用</h2><p>Timer是一个调度器，里面调度的方法TimeTask由自己实现，一个简单的例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();  </span><br><span class="line">timer.schedule(<span class="keyword">new</span> TimerTask() &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"abc"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">&#125;, <span class="number">10000</span> , <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码意思是在10s后每隔1s执行一次run()方法。</p>
<h3 id="Timer的构造方法："><a href="#Timer的构造方法：" class="headerlink" title="Timer的构造方法："></a>Timer的构造方法：</h3><p>从源码的角度来学习几个构造方法。</p>
<ol>
<li>构造方法1：无参构造方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Timer-"</span> + serialNumber());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>内部实际上调用Timer(String name)这个构造方法。</p>
<ol>
<li><p>构造方法2：设置守护线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(<span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Timer-"</span> + serialNumber(), isDaemon);</span><br><span class="line">&#125;</span><br><span class="line">如果设置为守护线程，则主线程结束后，Timer自动结束，无须使用cancel来结束。</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法3：带参数String的构造方法，传入Timer线程的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个构造方法有两个功能，一个是设置线程名字，另一个是启动线程。thread这个变量的定义是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br></pre></td></tr></table></figure></p>
<p>而TimerThread这个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br></pre></td></tr></table></figure></p>
<p>从以上构造方法可知，Timer内部包装了一个线程，独立于外部线程，进行调度以及管理。TimerThread类是default类型，基本上是Timer类专用的类。</p>
<h3 id="Timer常用方法"><a href="#Timer常用方法" class="headerlink" title="Timer常用方法"></a>Timer常用方法</h3><p>下面来看一看Timer内常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay)</span>	<span class="comment">//经过delay ms后进行调度一次task</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, Date time)</span>		<span class="comment">//在time时间点调度一次task</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span><span class="comment">//在time时间点以period的时间间隔调度task</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="keyword">long</span> period)</span><span class="comment">//经过delay ms后以period的时间间隔调度task</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span><span class="comment">//与schedule类似，后文介绍其区别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, Date firstTime, <span class="keyword">long</span> period)</span><span class="comment">//方法同上</span></span></span><br></pre></td></tr></table></figure></p>
<p>schedule的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了sched这个private方法，将task传入。看传入的形参列表可以发现，第二个参数是时间，那么传入Date时直接把这个Date传入就可以了。<br>下面来看一看重载方法schedule(TimerTask task, long delay, long period)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现这个方法其实也是对sched方法的包装。第三个参数-period就是重复的时间。<br>再来看scheduleAtFixedRate这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现与上一个方法基本相同，只有period的符号不同。可能是因为不愿意增加一个参数，直接用period的符号来表示那个方法。<br>下面来讨论Timer类的 <strong> 核心：sched方法 </strong> ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constrain value of period sufficiently to prevent numeric</span></span><br><span class="line">    <span class="comment">// overflow while still being effectively infinitely large.</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">        period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Task already scheduled or cancelled"</span>);</span><br><span class="line">            task.nextExecutionTime = time;</span><br><span class="line">            task.period = period;</span><br><span class="line">            task.state = TimerTask.SCHEDULED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(task);</span><br><span class="line">        <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">            queue.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个操作中，对queue做了同步，可以认为是线程安全的。从以上源码可以看出，schd主要任务是把nextExecutionTime、period、state这三个参数传入task中，并将task添加到queue中，并对queue做一次notify()操作。<br>简而言之，就是将参数传入task并将其放入queue中。我们现在开始看看queue的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br></pre></td></tr></table></figure></p>
<p>继续来看一看TaskQueue()的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> TimerTask[] queue = <span class="keyword">new</span> TimerTask[<span class="number">128</span>];  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>; </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>可见，TaskQueue的结构非常简单，内部是一个数组，只要task的数目低于128是不会扩容的。其中还有很多方法，提供了类似于ArrayList的方法来管理，内部有很多排序之类的处理。<br>好了，此时可以得到这样的关系：一个Timer内部包装了“一个Thread”和“一个Task”队列，这个队列按照一定的方式将任务排队处理，包含的线程在Timer的构造方法调用时被启动，这个Thread的run方法无限循环这个Task队列，若队列为空且没发生cancel操作，此时会一直等待，如果等待完成后，队列还是为空，则认为发生了cancel从而跳出死循环，结束任务；循环中如果发现任务需要执行的时间小于系统时间，则需要执行，那么根据任务的时间片从新计算下次执行时间，若时间片为0代表只执行一次，则直接移除队列即可。</p>
<h3 id="Timer已经被取代"><a href="#Timer已经被取代" class="headerlink" title="Timer已经被取代"></a>Timer已经被取代</h3><p>太坑爹了。。学习了Timer后才在java并发编程实践中看到Timer这一章。书上介绍，TimerTask抛出异常时Timer并不会捕获，这就导致Timer异常结束，而使用者根本就不知道这个事情，使得已经被调度的线程和还未执行的线程都不会执行。这就是所谓的“线程泄漏”。在JDK5.0以后的版本中，使用DelayQueue来代替Timer。DelayQueue实现了BlockingQueue，管理一组Delay对象，可以提供安全的操作。<br>这就是错误的Timer行为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="线程池扩展"><a href="#线程池扩展" class="headerlink" title="线程池扩展"></a>线程池扩展</h2><ul>
<li>Executors.newScheduledThreadPool<br>来完成对调度队列中的线程池的处理，内部通过new ScheduledThreadPoolExecutor来创建线程池的Executor的创建，当然也可以调用：<br>*Executors.unconfigurableScheduledExecutorService<br>方法来创建一个DelegatedScheduledExecutorService其实这个类就是包装了下下scheduleExecutor，也就是这只是一个壳，英文理解就是被委派的意思，被托管的意思。</li>
</ul>
<blockquote>
<p>参考<a href="http://blog.csdn.net/xieyuooo/article/details/8607220" target="_blank" rel="external">Timer与TimerTask的真正原理&amp;使用介绍</a></p>
</blockquote>
<h1 id="线程的其他知识"><a href="#线程的其他知识" class="headerlink" title="线程的其他知识"></a>线程的其他知识</h1><p>按照书上第七章来进行补漏。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程的状态储存在Thread的State枚举内部类当中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Thread state for a thread which has not yet started.</span><br><span class="line">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">     * state is executing in the Java virtual machine but it may</span><br><span class="line">     * be waiting for other resources from the operating system</span><br><span class="line">     * such as processor.</span><br><span class="line">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">     * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">     * to enter a synchronized block/method or</span><br><span class="line">     * reenter a synchronized block/method after calling</span><br><span class="line">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Thread state for a waiting thread.</span><br><span class="line">     * A thread is in the waiting state due to calling one of the</span><br><span class="line">     * following methods:</span><br><span class="line">     * </span><br><span class="line">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">     * perform a particular action.</span><br><span class="line">     *</span><br><span class="line">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">     * on an object is waiting for another thread to call</span><br><span class="line">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">     * is waiting for a specified thread to terminate.</span><br><span class="line">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">     * A thread is in the timed waiting state due to calling one of</span><br><span class="line">     * the following methods with a specified positive waiting time:</span><br><span class="line">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Thread state for a terminated thread.</span><br><span class="line">     * The thread has completed execution.</span><br><span class="line">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>java的线程状态与经典的线程状态略有不同。经典线程状态是创建、就绪、运行、阻塞、挂起、终止。java线程模型是这样的：NEW是新建的状态；RUNNABLE状态包括了就绪和运行态，这种状态下线程即使暂停也是系统的原因；BLOCKED表示阻塞态，等待其他线程释放锁；WAITING指的是当前线程已经持有锁，调用wait()方法，等待其他线程将其唤醒；TIMED_WAITING是有时间限制的等待，即调用wait(long)方法后线程的状态；TERMINATED则表示线程的终止状态。</p>
<h2 id="进入不同的线程状态"><a href="#进入不同的线程状态" class="headerlink" title="进入不同的线程状态"></a>进入不同的线程状态</h2><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>新建线程在启动之前的状态就是NEW：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">    System.out.println(t.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>线程启动，未停止的状态就是RUNNABLE：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runnableState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(t.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>当一个线程获取锁，另一个线程等待时就是BLOCKED状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blockedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">                      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                         System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t1.setName( <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        t2.setName( <span class="string">"t2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>线程主动等待的状态就是WAITING<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitingState</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(t.getState());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>只需将上一段代码改为lock.wait(2000);即可显示这个状态。</p>
<h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>线程结束后就是终止状态。</p>
<h3 id="线程状态的作用"><a href="#线程状态的作用" class="headerlink" title="线程状态的作用"></a>线程状态的作用</h3><p>了解线程状态又有什么用呢？这是JVM进阶必备的知识，在系统中找到性能瓶颈、调优时作用巨大。在工具jstack中，可以观察线程的执行状态。如果某个线程经常wait，那么可能是notify有一定的问题，需要进行调优。当然，这属于相当高级的知识了，具体的实施以后在工作中慢慢来学习~</p>
<blockquote>
<p>参考<a href="http://www.jiacheo.org/blog/338" target="_blank" rel="external">java线程的几种状态</a></p>
</blockquote>
<h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>线程组是java线程所特有的概念。java中，线程组指的是java.lang.ThreadGroup类的对象，每个线程隶属于唯一一个线程组。这个线程组在线程创建时指定，并在线程生命周期内不可以更改。可以通过调用包含ThreadGroup类型参数的Thread类构造方法来指定线程所述线程组。如果没有指定， <strong> 线程默认属于main的系统线程组 </strong> 。除了系统线程，所有线程组都必须显示创建。<br>java中除了系统线程外的每个线程组又隶属于另一个线程组，可以在创建线程组时指定隶属的线程组。缺省为main。这样，所有的线程组组成了一个以main为根的线程树。<br>线程组管理一组线程，包括启动、中断、枚举等方法。用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_2ThreadGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"Searcher"</span>);</span><br><span class="line">        </span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        SearchTask searchTask = <span class="keyword">new</span> SearchTask(result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(threadGroup, searchTask);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//get message</span></span><br><span class="line">        System.out.println(<span class="string">"Number of Thread is: "</span> + threadGroup.activeCount());</span><br><span class="line">        System.out.println(<span class="string">"Information about the ThreadGroup"</span>);</span><br><span class="line">        threadGroup.list();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//get the state of thread</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[threadGroup.activeCount()];</span><br><span class="line">        threadGroup.enumerate(threads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadGroup.activeCount(); i++)</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + threads[i].getName()</span><br><span class="line">                    + <span class="string">":"</span> + threads[i].getState());</span><br><span class="line">        </span><br><span class="line">        waitFinish(threadGroup);</span><br><span class="line">        threadGroup.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitFinish</span><span class="params">(ThreadGroup threadGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (threadGroup.activeCount() &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程，随机进行睡眠</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Result result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchTask</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> value = random.nextInt(<span class="number">10</span>);</span><br><span class="line">        System.out.printf(<span class="string">"Thread %s sleep %d\n"</span>, Thread.currentThread().getName(), value);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.printf(<span class="string">"Thread %s: Start\n"</span>, name);</span><br><span class="line">        doTask();</span><br><span class="line">        result.setName(name);</span><br><span class="line">        System.out.printf(<span class="string">"Thread %s: End\n"</span>,name);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对线程异常的处理"><a href="#对线程异常的处理" class="headerlink" title="对线程异常的处理"></a>对线程异常的处理</h2><p>线程中出现的异常可以用专门的线程处理，只需要调用Thread的setDefaultUncaughtExceptionHandler方法进行处理。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">_3Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">8</span> / <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtExceptionHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + t.getName() + <span class="string">" has exception"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>概念参考于<a href="http://blog.csdn.net/cuiran/article/details/6146560" target="_blank" rel="external">第六部分 线程组</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/17/Java多线程编程-三/" data-id="cipwm8pwc0002zsjemj2vrr3a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/21/Java多线程编程-四/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java多线程编程(四)
        
      </div>
    </a>
  
  
    <a href="/2016/06/15/Java多线程编程-二/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java多线程编程(二)</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      <a href="https://github.com/steven5538/hexo-theme-athena" target="_blank">Athena</a> by <a href="http://steven5538.tw" target="_blank">Steven5538</a> | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>